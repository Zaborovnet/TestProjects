<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>402</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <widget class="QWidget" name="gridLayoutWidget">
    <property name="geometry">
     <rect>
      <x>20</x>
      <y>130</y>
      <width>751</width>
      <height>136</height>
     </rect>
    </property>
    <layout class="QGridLayout" name="gridLayout">
     <item row="1" column="0">
      <widget class="QTextEdit" name="TicketOffices"/>
     </item>
     <item row="2" column="1">
      <widget class="QPushButton" name="Accept_btn">
       <property name="text">
        <string>Accept</string>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QPlainTextEdit" name="plainTextEdit">
       <property name="readOnly">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item row="0" column="2">
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>Array of minutes for each customer</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Count of self-service ticket offices</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QTextEdit" name="MinutesArray"/>
     </item>
     <item row="2" column="2">
      <widget class="QCheckBox" name="checkBox">
       <property name="text">
        <string>Use custom vector </string>
       </property>
      </widget>
     </item>
    </layout>
   </widget>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>



#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  MainWindow w;
  w.show();
  return a.exec();
}



#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QDebug>
#include <QTimer>

MainWindow::MainWindow(QWidget *parent)
  : QMainWindow(parent)
  , ui(new Ui::MainWindow)
{
  _countAllPeople_ui = 0;
  _countComletePeople_ui = 0;
  _useCustomVevtor_b = false;
  _startTimer_b = false;
  _minutesCustomersCustom_po = nullptr;
  ui->setupUi(this);
  connect(ui->Accept_btn, &QPushButton::clicked, this, &MainWindow::Accept_v);
  _BaseTimer_po = new QTimer(this);
  connect(_BaseTimer_po, &QTimer::timeout, this, &MainWindow::TickProcess_v);
  _BaseTimer_po->start(10);

}

MainWindow::~MainWindow()
{
  Reset_v();
  delete ui;
}

void MainWindow::Accept_v(bool flag_b)
{
  Q_UNUSED(flag_b);
  // Обнуляем все значения
  Reset_v();
  // Переводим QTextEdit c количеством касс в переменнеую
  _countTicketOffices_i = (ui->TicketOffices->toPlainText()).toUInt();

  //Переводим QTextEdit с количеством минут для каждого покупателя в вид вектора
  QString minutesInText_str = ui->MinutesArray->toPlainText();
  QStringList minites_lst = minutesInText_str.split('\n',
                                                    Qt::SkipEmptyParts); // Пропуск путсых строк


  // Если используем вектор со своим алокатаром
  if (ui->checkBox->isChecked()) {
    _useCustomVevtor_b = true;
    for (QString &minute_str : minites_lst) {
      bool check_b = false;
      minute_str.trimmed().toInt(&check_b); //пропуск пустых строк

      if (check_b) {
        ++_countAllPeople_ui;
      }
    }

    // Создаём аллокатар на количество касс
    FixedSizeAllocator<int> alloc_o(_countAllPeople_ui);
    // Создаём вектор с этим аллокатором
    _minutesCustomersCustom_po = new std::vector<int, FixedSizeAllocator<int>>(alloc_o);
    // Чтобы не запрашивал дополнительную память
    _minutesCustomersCustom_po->reserve(_countAllPeople_ui);

    for (QString &minute_str : minites_lst) {
      bool check_b = false;
      int value_i = minute_str.trimmed().toInt(&check_b); //пропуск пустых строк

      if (check_b) // если преобразования корректно прошли
      {
        _minutesCustomersCustom_po->push_back(value_i);
      }
    }

    qDebug() << "Count of self-service ticket offices" << _countTicketOffices_i
             << "Array of minutes for each customer" << *_minutesCustomersCustom_po;
    _startTimer_b = true;

    return;
  }

  // Если используем вектор обычный
  else {
    _useCustomVevtor_b = false;
    for (QString &minute_str : minites_lst) {
      bool check_b = false;
      int value_i = minute_str.trimmed().toInt(&check_b); //пропуск пустых строк

      if (check_b) // если преобразования корректно прошли
      {
        _minutesCustomers_vec.push_back(value_i);
      }
    }

    qDebug() << "Count of self-service ticket offices" << _countTicketOffices_i
             << "Array of minutes for each customer" << _minutesCustomers_vec;
    _startTimer_b = true;

    return;
  }
}

int MainWindow::queueTime_i(int countOffices, std::vector<int> minutesCustomers)
{
  return 0;
}

int MainWindow::queueTimeCustom_i(int countOffices, std::vector<int, FixedSizeAllocator<int>> minutesCustomersCustom)
{
  return 0;
}

void MainWindow::TickProcess_v()
{
  if (_startTimer_b)
  {

  }
}

void MainWindow::Reset_v()
{
  _countTicketOffices_i = 0;
  _minutesCustomers_vec.clear();
  _startTimer_b = false;
  _useCustomVevtor_b = false;

  if (_minutesCustomersCustom_po != nullptr){
    delete _minutesCustomersCustom_po;
  }
}



#include <cstdlib>
#include <memory>
#include <vector>

template <typename T>
class FixedSizeAllocator {
  public:
  using value_type = T;

  explicit FixedSizeAllocator(size_t capacity)
    : _capacity_u(capacity), _buffer_po(nullptr), _allocated_u(0) {}

  template <typename U>
  FixedSizeAllocator(const FixedSizeAllocator<U>& other)
    : _capacity_u(other._capacity_u), _buffer_po(nullptr), _allocated_u(0) {}

  T* allocate(size_t n) {
    // Создаём вектор
    if (_buffer_po == nullptr) {
      // Если количество элементов больше чем максимальное количество контейнера выкидываем bad_alloc
      if (n > _capacity_u)
        throw std::bad_alloc();
      // Выделяем блок памяти размером _capacity_u * sizeof(T)
      _buffer_po = static_cast<T*>(std::malloc(_capacity_u * sizeof(T)));
      if (!_buffer_po)
        throw std::bad_alloc();
      // Количество нужных элементов
      _allocated_u = n;
      return _buffer_po;
    }
    // Выделяем память из уже созданног блока (если осталось место)
    if (_allocated_u + n > _capacity_u)
      throw std::bad_alloc();

    // Возвращаем указатель на следующую свободную позицию
    T* ptr = _buffer_po + _allocated_u;
    _allocated_u += n;
    return ptr;
  }

  void deallocate(T* p, size_t n) noexcept {
    // Освобождаем только при разрушении аллокатора
  }

  size_t capacity() const { return _capacity_u; }

  ~FixedSizeAllocator() {
    std::free(_buffer_po);
  }

  private:
  size_t _capacity_u;     ///< @brief Максимальное количество элементов
  T* _buffer_po;          ///< @brief Указатель на выделенный блок памяти
  size_t _allocated_u;    ///< @brief Количество уже выделенных элементов (счётчик)
};

// Для совместимости с STL
template <typename T, typename U>
bool operator==(const FixedSizeAllocator<T>&, const FixedSizeAllocator<U>&) {
  return true;
}

template <typename T, typename U>
bool operator!=(const FixedSizeAllocator<T>& a, const FixedSizeAllocator<U>& b) {
  return !(a == b);
}



QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    main.cpp \
    mainwindow.cpp

HEADERS += \
    FixedSizeAllocator.h \
    mainwindow.h

FORMS += \
    mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target



#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include "FixedSizeAllocator.h"

QT_BEGIN_NAMESPACE
namespace Ui {
class MainWindow;
}
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
  Q_OBJECT

  public:
  MainWindow(QWidget *parent = nullptr);
  ~MainWindow();

  private:
  void Reset_v();                         ///@brief сброс всех параметров
  void TickProcess_v();                   ///@brief Выполняем обновление
  int queueTime_i(int countOffices, std::vector<int> minutesCustomers); ///@brief получаем количество минут для очереди покупателей
  int queueTimeCustom_i(int countOffices, std::vector<int, FixedSizeAllocator<int>> minutesCustomersCustom); ///@brief получаем количество минут для очереди покупателей


  Ui::MainWindow *ui;                     ///@brief указатель на UI
  unsigned int _countComletePeople_ui;    ///@brief количество людей, которые прошли
  unsigned int _countAllPeople_ui;        ///@brief количество всех людей
  QTimer *_BaseTimer_po;                  ///@brief указатель на таймер
  int _countTicketOffices_i;              ///@brief количество автоматов (касс)
  std::vector<int> _minutesCustomers_vec; ///@brief вектор минут относительно каждого в очереде
  std::vector<int, FixedSizeAllocator<int>> * _minutesCustomersCustom_po; ///@brief вектор минут относительно каждого в очереде (со своим аллокатором)

  bool _useCustomVevtor_b; ///@brief исполоьзование _minutesCustomersCustom_po
  bool _startTimer_b; ///@brief запуск отсчёта очереди


  private slots:
  void Accept_v(bool flag_b);


};
#endif // MAINWINDOW_H



